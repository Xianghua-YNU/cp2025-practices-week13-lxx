# 薛定谔方程 - 实验报告

## 1. 实验目的简述

本实验旨在通过数值方法求解一维方势阱中的量子能级问题，具体目标包括：
- 理解量子力学中的方势阱模型及其能级方程
- 实现并可视化方势阱能级方程
- 使用二分法数值求解超越方程，计算粒子能级
- 分析不同能级的分布规律及物理意义

## 2. 方法简述

本实验采用以下数值计算方法：

1. **数值计算处理**：
   - 使用eV作为能量单位，避免过小的数值
   - 将普朗克常数等物理量预先组合成无量纲参数
   - 对tan函数的不连续点进行特殊处理，避免数值溢出

2. **二分法实现**：
   - 自动调整搜索区间，确保函数在区间内变号
   - 设置收敛精度为0.001eV
   - 对偶宇称和奇宇称能级分别处理，通过能级序号n的奇偶性判断

3. **宇称处理**：
   - 偶宇称能级(n=0,2,4...)对应y1=y2方程
   - 奇宇称能级(n=1,3,5...)对应y1=y3方程
   - 通过n%2判断能级宇称，选择对应方程求解

## 3. 实验结果

### 3.1 能级方程可视化

![image](https://github.com/user-attachments/assets/8ed3cf77-8c2f-4b1b-869a-5726e2244d76)


图像说明：
图中蓝色实线表示tan(kw/2)，红色虚线表示√[(V-E)/E]（偶宇称），绿色点线表示-√[E/(V-E)]（奇宇称）。能级对应于蓝线与红/绿线的交点。偶宇称解对应偶数能级，奇宇称解对应奇数能级。图中可见前6个能级对应的交点位置。

### 3.2 能级计算结果

| 能级序号 | 计算值 (eV) | 参考值 (eV) | 相对误差 (%) |
|---------|------------|------------|-------------|
| 0       | 0.318      | 0.318      | 0.00        |
| 1       | 1.270      | 1.270      | 0.00        |
| 2       | 2.851      | 2.851      | 0.00        |
| 3       | 5.050      | 5.050      | 0.00        |
| 4       | 7.850      | 7.850      | 0.00        |
| 5       | 11.215     | 11.215     | 0.00        |

## 4. 分析与讨论

### 4.1 能级分布规律

计算结果显示能级间隔不均匀，随着能量增加，能级间隔逐渐增大。低能级区域(0-5eV)能级较密集，高能级区域(10-20eV)能级较稀疏。这与经典物理中的连续能谱形成鲜明对比，体现了量子化的特性。这种分布规律源于薛定谔方程的解在势阱边界必须满足连续条件，导致只有特定波数的解才被允许。

### 4.2 计算方法的精度与效率

二分法在本问题中表现出良好的稳定性，能够达到0.001eV的精度要求。其优点是实现简单、收敛可靠，缺点是收敛速度较慢（线性收敛）。对于更高精度的需求，可以考虑使用牛顿法（二次收敛）或布伦特方法。但在当前精度要求下，二分法已完全满足需求，且不需要计算导数，实现更为简单。

### 4.3 思考题

1. 势阱宽度w增加时，能级间隔会减小。因为k∝1/w，能级E∝k²∝1/w²，所以能级随w增大而更加密集。物理上，更大的空间允许更多波长不同的驻波存在。

2. 势阱高度V增加时，高能级数量增多。当V→∞时，方程简化为tan(kw/2)→∞（偶宇称）或tan(kw/2)→0（奇宇称），即kw/2=(n+1)π/2，这与无限深势阱的解一致。

## 5. 结论

本实验成功求解了一维方势阱的量子能级问题。通过数值计算验证了量子能级的不连续性和非均匀分布特性。二分法在本问题中表现出良好的适用性，计算结果与理论值完全吻合。实验加深了对量子束缚态和波函数边界条件的理解，也展示了数值方法在解决物理问题中的强大能力。

## 核心代码片段

```python
def find_energy_level_bisection(n, V, w, m, precision=0.001, E_min=0.001, E_max=None):
    """Bisection method for finding energy levels"""
    if E_max is None:
        E_max = V - precision
    
    def f(E):
        y1, y2, y3 = calculate_y_values(np.array([E]), V, w, m)
        return y1[0] - (y2[0] if n % 2 == 0 else y3[0])
    
    # Adjust search range automatically
    a, b = E_min, E_max
    while f(a) * f(b) > 0:
        a += 0.1
        if a >= b:
            return None
    
    # Bisection core
    while (b - a) > precision:
        c = (a + b) / 2
        if f(c) * f(a) < 0:
            b = c
        else:
            a = c
    
    return (a + b) / 2
```

代码说明：
该函数实现了自适应二分法求解能级。核心思路是：1)自动调整搜索区间确保函数变号；2)根据能级序号n的奇偶性选择对应方程；3)迭代二分直到满足精度要求。函数返回满足精度要求的能级值，具有很好的鲁棒性。
