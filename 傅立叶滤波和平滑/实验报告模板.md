# 傅立叶滤波和平滑 - 实验报告

## 1. 实验目的

本实验旨在通过对道琼斯工业平均指数数据进行傅立叶变换和滤波处理，达到以下目标：
- 掌握傅立叶变换在金融时间序列分析中的应用
- 理解不同频率成分对信号的影响
- 学习通过频域滤波提取信号特征的方法
- 分析滤波参数变化对结果的影响

## 2. 方法简述

本实验采用以下方法实现傅立叶滤波分析：

1. **数据加载和预处理**：使用NumPy的`loadtxt`函数直接加载文本格式的道琼斯指数数据，无需额外预处理。

2. **傅立叶变换实现**：采用`numpy.fft.rfft`计算实数信号的离散傅立叶变换，该函数针对实数输入进行了优化，仅返回非冗余的频率分量。

3. **滤波器设计**：通过设置保留前10%和前2%的傅立叶系数实现低通滤波。具体步骤为：计算傅立叶系数→确定保留系数数量→将剩余系数置零→进行逆变换。

4. **可视化方法**：使用Matplotlib绘制时间序列图，原始数据用蓝色半透明线条表示，滤波结果用红色实线表示，并添加网格线和图例增强可读性。

5. **逆变换实现**：使用`numpy.fft.irfft`将滤波后的频域信号转换回时域，确保结果长度与原始数据一致。

## 3. 实验结果

### 3.1 原始数据时间序列

![image](https://github.com/user-attachments/assets/b54eab07-da1a-4c5b-9faa-062c7bed7a93)


图像说明：
原始数据展示了2006-2010年间道琼斯指数的每日收盘价。图中可见2008年金融危机期间指数从约14000点暴跌至7000点左右的剧烈波动，随后呈现复苏趋势。数据整体呈现明显的非平稳性，包含长期趋势和短期波动。

### 3.2 保留前10%系数的滤波结果

![image](https://github.com/user-attachments/assets/bc518dd8-c890-4f2f-a39f-6ebd6027c66b)


图像说明：
保留前10%系数的滤波结果（红色）相比原始数据（蓝色）明显平滑，但仍保留了主要波动特征。2008年的下跌趋势和后续复苏趋势被完整保留，而日内的小幅波动被有效抑制。这种滤波强度适合分析季度级别的市场趋势。

### 3.3 保留前2%系数的滤波结果

![image](https://github.com/user-attachments/assets/784442c0-a16c-46b8-b7fd-45960951f4b2)


图像说明：
仅保留2%系数的滤波结果更加平滑，几乎变成了单调曲线。金融危机期间的V型反转特征被弱化为平缓的U型曲线。这种滤波强度仅适合分析多年期的超长期趋势，完全失去了对市场中期波动的描述能力。

## 4. 分析与讨论

### 4.1 不同滤波参数的影响

保留10%系数的滤波在保留主要趋势的同时有效去除了噪声，适合大多数趋势分析场景。而2%滤波虽然更加平滑，但丢失了过多有价值的中期波动信息，可能导致趋势判断失真。实验表明，过度滤波会：
1. 弱化重要的市场转折点特征
2. 延迟趋势变化的检测时间
3. 掩盖市场的重要波动周期
理想的滤波强度应根据具体分析目标在5%-15%之间选择，平衡平滑度和信息保留度。

### 4.2 金融时间序列的频率特征

低频成分（>6个月周期）主要反映：
- 宏观经济周期（GDP增长、通胀等）
- 货币政策变化
- 产业结构调整

高频成分（<1个月周期）主要包含：
- 市场流动性波动
- 短期投机行为
- 突发事件冲击
- 交易噪声

中频成分（1-6个月）则往往反映：
- 季度财报影响
- 行业景气度变化
- 投资者情绪波动

### 4.3 思考题

1. **对数变换的影响**：对数据进行对数变换后，傅立叶分析将更关注相对变化率而非绝对变化量。这能更好地处理金融数据的异方差性，使各时期的波动具有可比性，但不会改变基本的频率分布特征。

2. **非周期性问题**：金融数据的非周期性会导致：
- 频谱泄漏现象
- 端点效应（首尾数据不连续）
- 虚假高频成分产生
可通过加窗函数（如汉宁窗）或使用小波变换等时频分析方法缓解。

## 5. 结论

本实验验证了傅立叶滤波在金融时间序列分析中的有效性。通过调节保留系数比例，可以灵活提取不同时间尺度的市场特征。实验发现10%左右的保留比例在趋势分析和噪声抑制之间取得了良好平衡。主要挑战在于选择适当的滤波强度以避免信息丢失，解决方法是通过交叉验证确定最优参数。本技术可扩展应用于趋势线生成、波动率估计等多种金融分析场景。

## 核心代码片段

```python
def fourier_filter(data, keep_fraction=0.1):
    """傅立叶滤波核心函数"""
    fft_coeff = np.fft.rfft(data)  # 实数傅立叶变换
    n_coeff = len(fft_coeff)
    cutoff = int(n_coeff * keep_fraction)  # 计算截止点
    
    filtered_coeff = fft_coeff.copy()
    filtered_coeff[cutoff:] = 0  # 高频成分置零
    
    filtered_data = np.fft.irfft(filtered_coeff, n=len(data))
    return filtered_data, fft_coeff
```

代码说明：
该函数实现了傅立叶滤波的核心流程：首先对输入数据进行实数傅立叶变换，然后根据keep_fraction参数计算需要保留的低频系数数量，将剩余高频系数置零后，通过逆变换重构时域信号。关键点在于rfft/irfft的配对使用确保数据长度一致，以及通过数组切片操作实现频域滤波。
